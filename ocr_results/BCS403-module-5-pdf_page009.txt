Database Management System [BCS403]

Both schemes end up aborting the younger of the two transactions (the transaction that
started later) that may be involved in a deadlock, assuming that this will waste less
processing.
It can be shown that these two techniques are deadlock-free, since in wait-die,
transactions only wait for younger transactions so no cycle is created.
Similarly, in wound-wait, transactions only wait for older transactions so no cycle is
created.
Another group of protocols that prevent deadlock do not require timestamps. These
include the

* no waiting (NW) and

* cautious waiting (CW) algorithms
= No waiting algorithm,

—if a transaction is unable to obtain a lock, it-is,immediately aborted and then
restarted after a certain time delay without checking whether a deadlock will
actually occur or not.

— no transaction ever waits, so no deadlock will occur

— this scheme can cause transactions to abort.and restart needlessly

= cautious waiting
— try to reduce the number of needless aborts/restarts
—- Suppose that transaction Ti tries to lock an item X but is not able to do so because
X is locked by some other transaction Tj with a conflicting lock.
—The cautious waiting rules are as follows:
= df Tj is not blocked (not waiting for some other locked item), then Ti is
blocked and allowed to wait; otherwise abort Ti.
— It can be shown that cautious waiting is deadlock-free, because no transaction will

ever wait for another blocked transaction.

5.12 Deadlock Detection.

A second, more practical approach to dealing with deadlock is deadlock detection,
where the system checks if a state of deadlock actually exists.

This solution is attractive if we know there will be little interference among the
transactions—that is, if different transactions will rarely access the same items at the

same time.

https://vtucode.in 31