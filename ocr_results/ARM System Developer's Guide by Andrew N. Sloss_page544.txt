14.10 Demonstration: A Small Virtual Memory System 531

return -1;

mov rO, PTE
mov rl, PTE
mov r2, PTE
mov r3, PTE

}
for (; index != 0; index--)
{
_asm
{
STMIA PTEptr!, {r0-r3} /* write 32 entries to table */
STMIA PTEptr!, {r0-r3}
STMIA PTEptr!, {r0-r3}
STMIA PTEptr!, {r0-r3}
STMIA PTEptr!, {r0-r3}
STMIA PTEptr!, {r0-r3}
STMIA PTEptr!, {r0-r3}
STMIA PTEptr!, {r0-r3}
}
}
return 0;
}

mmuInitPT starts with the base page table address PTEptr and fills the page table with
FAULT entries. The size of the table is determined by reading the type of Paget ab1e defined
in pt->type. The table type can be the master L1 page table with 4096 entries, a coarse L2
page table with 256 entries, or a fine L2 page table with 1024 entries.

The routine fills the table by writing small blocks to memory using a loop. The routine
determines the number of blocks to write index from the number of entries in the page table
divided by the number of entries written per loop. A switch statement selects the Pagetable
type and branches to the case that sets the index size for the table. The procedure completes
by executing the loop that fills the table. Note the __asm keyword to invoke the inline
assembler; this reduces the execution time of the loop by using the stmia store multiple
instruction.

14.10.6.2 Filling Page Tables with Translations

The second part in initializing the MMU is to convert the data held in the RCB into
page table entries and to copy them into the page tables. We provide several routines