222 Chapter 7 Optimized Primitives

SUBCC Yr, r, m
ADCS or, m, r, LSL #1

SUBCC r, r, m

; extract answer and remainder (if required)

ADC rd, r, r ; insert final answer bit
MOV, rO, LSR #15 5 extract remainder

BIC 0, r0, r, LSL #15 ; extract quotient

MOV pe, Ir return { r0, r }
quotient oveflows 15 bits
maximum quotient

overflow 15

LOR r0, =Ox7fff

Mov rl, r0 maximum remainder
MOV pe, Ir 3 return { Ox7fff, Ox7fff }
We start by setting m = —d2!*. Instead of subtracting a shifted version of the denomin-

ator from the remainder, we add the negated denominator to the shifted remainder. After
the Ath trial subtraction step, the bottom k bits of r hold the k top bits of the quotient.
The upper 32 — k bits of r hold the remainder. Each ADC instruction performs three
functions:

= It shifts the remainder left by one.
= Itinserts the next quotient bit from the last trial subtraction.

= It subtracts d < 14 from the remainder.

After 15 steps the bottom 15 bits of r contain the quotient and the top 17 bits contain
the remainder. We separate these into r0 and rl, respectively. Excluding the return, the
division takes 35 cycles on ARM7TDMI.

7.3.1.3 Unsigned 64/31-Bit Divide by Trial Subtraction

This operation is useful when you need to divide Q31 fixed-point integers (see Section 8.1.5).
It doubles the precision of the division in Section 7.3.1.2. The numerator nis an unsigned
64-bit integer. The denominator d is an unsigned 31-bit integer. The following routine
returns a structure containing the 32-bit quotient q and remainder r. The result overflows
ifn > d2>. In this case we return the maximum possible quotient of Oxffffffff. The
routines takes 99 cycles on ARM7TDML using a three-bit-per-cycle trial subtraction. In the
code comments we use the notation [r, q] to mean a 64-bit value with upper 32 bits rand
lower 32 bits q.

m RN O ; input denominator d, -d
r RN 1 ; input numerator (low), remainder (high)
t RN 2 ; input numerator (high)

q RN 3 ; result quotient and remainder (Tow)