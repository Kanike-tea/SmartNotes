120. Chapter 5 Efficient C Programming

SUMMARY

sum += *(datat+) ;
}
return sum;

}

The second for loop handles the remaining cases when N is not a multiple of four. Note
that both N/4 and N&3 can be zero, so we can’t use do-whi le loops.

Writing Loops Efficiently

= Use loops that count down to zero. Then the compiler does not need to allocate
a register to hold the termination value, and the comparison with zero is free.

= Use unsigned loop counters by default and the continuation condition i !=0 rather than
i>0. This will ensure that the loop overhead is only two instructions.

= Use do-whi le loops rather than for loops when you know the loop will iterate at least
once. This saves the compiler checking to see if the loop count is zero.

= Unroll important loops to reduce the loop overhead. Do not overunroll. If the loop
overhead is small as a proportion of the total, then unrolling will increase code size and
hurt the performance of the cache.

= Try to arrange that the number of elements in arrays are multiples of four or eight. You
can then unroll loops easily by two, four, or eight times without worrying about the
leftover array elements.

5.4 REGISTER ALLOCATION

The compiler attempts to allocate a processor register to each local variable you use in
a C function. It will try to use the same register for different local variables if the use of the
variables do not overlap. When there are more local variables than available registers, the
compiler stores the excess variables on the processor stack, These variables are called spilled
or swapped out variables since they are written out to memory (in a similar way virtual
memory is swapped out to disk). Spilled variables are slow to access compared to variables
allocated to registers.
To implement a function efficiently, you need to

= minimize the number of spilled variables

= ensure that the most important and frequently accessed variables are stored in registers

First let’s look at the number of processor registers the ARM C compilers have avail-
able for allocating variables. Table 5.3 shows the standard register names and usage when
following the ARM-Thumb procedure call standard (ATPCS), which is used in code
generated by C compilers.