80 Chapter 3 Introduction to the ARM Instruction Set

Table 3.13 New instructions provided by the ARMVSE extensions.

Instruction

Description

CLZ {<cond>} Rd, Rm

QADD {<cond>} Rd, Rm, Rn
QDADD{<cond>} Rd, Rm, Rn
QDSUB{<cond>} Rd, Rm, Rn
QSUB{<cond>} Rd, Rm, Rn
SMLAxy{<cond>} Rd, Rm, Rs, Rn
SMLALxy{<cond>} RdLo, RdHi, Rm, Rs
SMLAWy{<cond>} Rd, Rm, Rs, Rn
SMULxy{<cond>} Rd, Rm, Rs
SMULWy{<cond>} Rd, Rm, Rs

count leading zeros
signed saturated 32-bit add

signed saturated double 32-bit add
signed saturated double 32-bit subtract
signed saturated 32-bit subtract

signed multiply accumulate 32-bit (1)
signed multiply accumulate 64-bit
signed multiply accumulate 32-bit (2)
signed multiply (1)

signed multiply (2)

3.7.1 COUNT LEADING ZEROS INSTRUCTION

The count leading zeros instruction counts the number of zeros between the most significant
bit and the first bit set to 1. Example 3.30 shows an example of a CLZ instruction.

EXAMPLE You can see from this example that the first bit set to 1 has 27 zeros preceding it. CLZ is
3.30 useful in routines that have to normalize numbers.

PRE â€”_ rl = 0b00000000000000000000000000010000
CLZ r0, ri
POST 0 = 27

3.7.2.) SATURATED ARITHMETIC

EXAMPLE

3.31

Normal ARM arithmetic instructions wrap around when you overflow an integer value.
For example, Ox7fffffff + 1 = -0x80000000. Thus, when you design an algorithm,
you have to be careful not to exceed the maximum representable value in a 32-bit integer.

This example shows what happens when the maximum value is exceeded.

PRE cpsr = nzcvqiFt_SVC
r0 = 0x00000000
rl = 0x70000000 (positive)
r2 = Ox7fffffff (positive)