378

Chapter 12 Object and Object-Relational Databases

a subtype ENGINEERING _MANAGER that is a subtype of both MANAGER and
ENGINEER. This leads to the creation of a type lattice rather than a type hierarchy.
One problem that can occur with multiple inheritance is that the supertypes from
which the subtype inherits may have distinct functions of the same name, creating an
ambiguity. For example, both MANAGER and ENGINEER may have a function called
Salary. If the Salary function is implemented by different methods in the MANAGER
and ENGINEER supertypes, an ambiguity exists as to which of the two is inherited by
the subtype ENGINEERING_MANAGER. It is possible, however, that both ENGINEER
and MANAGER inherit Salary from the same supertype (such as EMPLOYEE) higher
up in the lattice. The general rule is that if a function is inherited from some com-
mon supertype, then it is inherited only once. In such a case, there is no ambiguity;
the problem only arises if the functions are distinct in the two supertypes.

There are several techniques for dealing with ambiguity in multiple inheritance.
One solution is to have the system check for ambiguity when the subtype is created,
and to let the user explicitly choose which function is to be inherited at this time. A
second solution is to use some system default. A third solution is to disallow mul-
tiple inheritance altogether if name ambiguity occurs, instead forcing the user to
change the name of one of the functions in one of the supertypes. Indeed, some OO
systems do not permit multiple inheritance at all. In the object database standard
(see Section 12.3), multiple inheritance is allowed for operation inheritance of
interfaces, but is not allowed for EXTENDS inheritance of classes.

Selective inheritance occurs when a subtype inherits only some of the functions of
a supertype. Other functions are not inherited. In this case, an EXCEPT clause may
be used to list the functions in a supertype that are not to be inherited by the sub-
type. The mechanism of selective inheritance is not typically provided in ODBs, but
it is used more frequently in artificial intelligence applications.'Â°

12.1.7 Summary of Object Database Concepts

To conclude this section, we give a summary of the main concepts used in ODBs
and object-relational systems:

= Object identity. Objects have unique identities that are independent of their
attribute values and are generated by the ODB system.

= Type constructors. Complex object structures can be constructed by apply-
ing in a nested manner a set of basic type generators/constructors, such as
tuple, set, list, array, and bag.

= Encapsulation of operations. Both the object structure and the operations that
can be applied to individual objects are included in the class/type definitions.

= Programming language compatibility. Both persistent and transient objects
are handled seamlessly. Objects are made persistent by being reachable from

'8in the ODMG model, type inheritance refers to inheritance of operations only, not attributes (see
Section 12.3).