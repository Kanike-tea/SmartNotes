EXAMPLE

8.11

8.3 FIR filters 287

MLA a3, x1, ¢.0, a.
MLA a0, x 3, cl, a0
LORSH x_3, [x], #2

MLA al, x0, cl, al

MLA a2, x1,cl, a2

MLA a3, x2, cl, a3

BGT —next_tap_arm9m

LOMFD sp! {N, M}

STMIA al, {a_0, al, a2, a3}

SUB, c, M, LSL#1 3 restore coefficient pointer
SUB x, x, M, LSL#1 ; advance data pointer

suBS oN, N, #4 ; filtered four samples

BGT —next_sample_arm9m

LOMFD sp!, {r4-rl1, pc}

The code is scheduled so that we don’t use a loaded value on the following two cycles.
We've moved the loop counter decrement to the start of the loop to fill a load delay slot.

Each iteration of the inner loop processes the next four coefficients and updates four
filter outputs. Assuming the coefficients are 16 bits, each multiply accumulate requires
4 cycles. Therefore it processes 16 filter taps in 76 cycles, giving a block FIR rating of
4.75 cycles/tap.

This code also works well for other ARMv4 architecture processors such as the
StrongARM. On StrongARM the inner loop requires 61 cycles, or 3.81 cycles/tap.

The ARMOE has a faster multiplier than previous ARM processors. The ARMVSTE 16-bit
multiply instructions also unpack 16-bit data when two 16-bit values are packed into
a single 32-bit word. Therefore we can store more data and coefficients in registers and use
fewer load instructions.

This example implements a 6 x 6 block filter for ARMv5TE processors. The routine
is rather long because it is optimized for maximum speed. If you don’t require as much
performance, you can reduce code size by using a4 x 4 block implementation.

The input and output arrays have the same format as Example 8.9, except that the
input arrays are now 16-bit values. The number of outputs and coefficients, N and M,
must be multiples of six. The input arrays must be 32-bit aligned and the memory system
little-endian. If you need to write endian-neutral routines, then you should replace SMLAxy
instructions by macros that change the T and B settings according to endianness. For
example the following macro, SMLAQO, evaluates to SMLABB or SMLATT for little- or big-
endian memory systems, respectively. If b and c are read as arrays of 16-bit values, then
SMLAOO always multiplies b[0] by c[0] regardless of endianness.

MACRO
SMLAOO $a, $b, $c, $d