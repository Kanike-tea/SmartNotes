620 Chapter 17 Indexing Structures for Files and Physical Database Design

a node that makes it less than half full. More formally, a B-tree of order p, when
used as an access structure on a key field to search for records in a data file, can be
defined as follows:

1. Each internal node in the B-tree (Figure 17.10(a)) is of the form
<P), <Kj, Pry>, Po, <Ky, Pr2>, ... , <Kq-1s Prg-1>» Pq>

where q < p. Each P; is a tree pointer—a pointer to another node in the
B-tree. Each Pr; is a data pointer!’—a pointer to the record whose search
key field value is equal to K; (or to the data file block containing that record).

2. Within each node, K; < K, <<... < Kg.

3. For all search key field values X in the subtree pointed at by P; (the ith sub-
tree, see Figure 17.10(a)), we have:

Kj_. < X< K; for 1 <i<q;X<K;fori=1; and K;_, < X fori=q

4. Each node has at most p tree pointers.

5. Each node, except the root and leaf nodes, has at least | (p/2) | tree pointers.
The root node has at least two tree pointers unless it is the only node in
the tree.

6. A node with q tree pointers, q < p, has q — 1 search key field values (and
hence has q — 1 data pointers).

7. All leaf nodes are at the same level. Leaf nodes have the same structure as
internal nodes except that all of their tree pointers P; are NULL.

Figure 17.10(b) illustrates a B-tree of order p = 3. Notice that all search values K in
the B-tree are unique because we assumed that the tree is used as an access structure
ona key field. If we use a B-tree on a nonkey field, we must change the definition of
the file pointers Pr; to point to a block—or a cluster of blocks—that contain the
pointers to the file records. This extra level of indirection is similar to option 3, dis-
cussed in Section 17.1.3, for secondary indexes.

A B-tree starts with a single root node (which is also a leaf node) at level 0 (zero).
Once the root node is full with p — 1 search key values and we attempt to insert
another entry in the tree, the root node splits into two nodes at level 1. Only the
middle value is kept in the root node, and the rest of the values are split evenly
between the other two nodes. When a nonroot node is full and a new entry is
inserted into it, that node is split into two nodes at the same level, and the middle
entry is moved to the parent node along with two pointers to the new split nodes. If
the parent node is full, it is also split. Splitting can propagate all the way to the root
node, creating a new level if the root is split. We do not discuss algorithms for
B-trees in detail in this text,!! but we outline search and insertion procedures for
B*-trees in the next section.

1p data pointer is either a block address or a record address; the latter is essentially a block address
and a record offset within the block.

"For details on insertion and deletion algorithms for B-trees, consult Ramakrishnan and Gehrke (2008).