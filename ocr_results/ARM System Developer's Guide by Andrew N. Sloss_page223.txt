210 Chapter 7 Optimized Primitives

abs al, al, c0
ADCS a2, a2, b0
ADC a3, a3, #0
3 return wrapper
Mov. rd, a0
Mov orl, al
MOV r2, a2
MOV 3, a3
LOMFD sp!, —{r4,r5,pc}

The second method works better on the ARM9TDMI and ARMOE. Here multiply
accumulates are as fast as multiplies. We schedule the multiply instructions to avoid
result-use interlocks on the ARMOE (see Section 6.2 for a description of pipelines and
interlocks).

3 _value_in_regs struct { unsigned a0,al,a2,a3; }

3 umul_64t0128_arm9e(unsigned long long b,

3 unsigned long long c)
umu1_64t0128_arm9e

STMFD  sp!, {r4,r5,1r}

3 unsigned 128-bit a = 64-bit b * 64-bit c

UMULL a0, al, b_0, c0 ; low*low

MoV a2, #0

UMLAL al, a2, b.0, cl ; low*high

MoV a3, #0

UMLAL al, a3, bl, c0 ; high*low

MoV b.0, #0

ADDS a2, a2, a3

ADC a3, b0, #0

UMLAL a2, a3, bl, cl = ; high*high

3 return wrapper

Mov. rd, a0

Mov orl, al

MOV r2, a2

MOV 3, a3

LOMFD sp!, —{r4,r5,pc}

Excluding the function call and return wrapper, this implementation requires 33 cycles
on ARM9TDMI and 17 cycles on ARMOE. The idea is that the operation ab + c+ d cannot
overflow an unsigned 64-bit integer if a, b, c, and d are unsigned 32-bit integers. Therefore
you can achieve long multiplications with the normal schoolbook method of using the
operation ab + c + d, where c and d are the horizontal and vertical carries.