7.2 Input Enhancement in String Matching 259

requires finding an occurrence of a given string of m characters called the pattern
in a longer string of n characters called the text. We discussed the brute-force
algorithm for this problem in Section 3.2: it simply matches corresponding pairs
of characters in the pattern and the text left to right and, if a mismatch occurs,
shifts the pattern one position to the right for the next trial. Since the maximum
number of such trials is n — m + 1 and, in the worst case, m comparisons need to
be made on each of them, the worst-case efficiency of the brute-force algorithm is
in the O(nm) class. On average, however, we should expect just a few comparisons
before a pattern’s shift, and for random natural-language texts, the average-case
efficiency indeed turns out to be in O(n + m).

Several faster algorithms have been discovered. Most of them exploit the
input-enhancement idea: preprocess the pattern to get some information about
it, store this information in a table, and then use this information during an actual
search for the pattern in a given text. This is exactly the idea behind the two best-
known algorithms of this type: the Knuth-Morris-Pratt algorithm [Knu77] and the
Boyer-Moore algorithm [Boy77].

The principal difference between these two algorithms lies in the way they
compare characters of a pattern with their counterparts in a text: the Knuth-
Morris-Pratt algorithm does it left to right, whereas the Boyer-Moore algorithm
does it right to left. Since the latter idea leads to simpler algorithms, it is the
only one that we will pursue here. (Note that the Boyer-Moore algorithm starts
by aligning the pattern against the beginning characters of the text; if the first
trial fails, it shifts the pattern to the right. It is comparisons within a trial that the
algorithm does right to left, starting with the last character in the pattern.)

Although the underlying idea of the Boyer-Moore algorithm is simple, its
actual implementation in a working method is less so. Therefore, we start our
discussion with a simplified version of the Boyer-Moore algorithm suggested by
R. Horspool [Hor80]. In addition to being simpler, Horspool’s algorithm is not
necessarily less efficient than the Boyer-Moore algorithm on random strings.

Horspool’s Algorithm

Consider, as an example, searching for the pattern BARBER in some text:

SQ see Cow. Spd
BARBER

Starting with the last R of the pattern and moving right to left, we compare the
corresponding pairs of characters in the pattern and the text. If all the pattern’s
characters match successfully, a matching substring is found. Then the search
can be either stopped altogether or continued if another occurrence of the same
pattern is desired.

If a mismatch occurs, we need to shift the pattern to the right. Clearly, we
would like to make as large a shift as possible without risking the possibility of
missing a matching substring in the text. Horspool’s algorithm determines the size