152 Chapter 5 Efficient C Programming

EXAMPLE

5.17

ADDS a, a, i /* accumulate */
EORVS a, mask, a, ASR 31 /* saturate the accumulate */
}
#endif
#ifdef _ GNUC__ /* check for the gcc compiler */
asm("ADDS %0, %1, %2 "ter" (i): "nM

asm("EORVS %0, %1, %2,ASR#31'
asm("ADDS%0, %1, %2 "

(a) : "cc") 5

asm("EORVS %0, 1, %2,ASR#31":"=r" (a):"r" (mask),
#endif

return a;
}

This inlined code reduces the main loop of sat_correlate from 19 instructions to
9 instructions.

Now suppose that we are using an ARMYE processor with the ARMvS5E extensions. We can
rewrite qmac again so that the compiler uses the new ARMv5E instructions:

__inline int gmac(int a, int x, int y)
{

int i;

__asm

{
SMULBB i, x, y /* multiply */
QDADD a, a, i /* double + saturate + accumulate + saturate */

}

return a;
}

This time the main loop compiles to just six instructions:

sat_correlate_v3
STR r14,[r13,#-4]! ; stack Ir

Mov 112, #0 3 a=0
sat_v3_loop
LDRSH 3, [rO] ,#2 33 = *(xt+4)
LORSH 14, [r1] ,#2 3 rld = *(y++)

SUBS r2,r2,#1 3 Ne- and set flags