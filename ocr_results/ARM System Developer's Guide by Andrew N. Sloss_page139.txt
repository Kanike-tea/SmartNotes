126 Chapter 5 Efficient C Programming

SUMMARY

}
return d - 10 + 'A‘;

}

void uint_to_hex(char *out, unsigned int in)
{

unsigned int i;

for (i=8; i!=05
{
in = (in<<4) | (in>>28); /* rotate in left by 4 bits */
*(out++) = (char)nybble_to_hex(in & 15);
}

}

When we compile this, we see that uint_to_hex doesn’t call nybble_to_hex at all!
In the following compiled code, the compiler has inlined the uint_to_hex code. This is
more efficient than generating a function call.

uint_to_hex

MOV r3,#8 3 i=8
uint_to_hex_loop
MOV rl,rl,ROR #28 3 in = (in<<4) | (in>>28)
AND r2yr1,#0xf 3 r2 = in &15
CMP r2,#0xa 3 if (r2>=10)
ADDCS r2,r2,#0x37 32 4s'A'=10
ADDCC r2,r2,#0x30 3 else r2 +='0'
TRB. r2,[r0], #1 3 *(out++) = r2
SUBS r3,r3,#1 3 i-- and set flags
BNE wint_to_hex_loop ; if (i!=0) goto loop
MOV pcyrl4 3 return

The compiler will only inline small functions. You can ask the compiler to inline
a function using the __inline keyword, although this keyword is only a hint and the
compiler may ignore it (see Section 5.12 for more on inline functions). Inlining large
functions can lead to big increases in code size without much performance improvement.

Calling Functions Efficiently

= Try to restrict functions to four arguments. This will make them more efficient to
call. Use structures to group related arguments and pass structure pointers instead of
multiple arguments.