Data Structures and Applications/BCS304 Module 1

Knuth, Morris, pratt pattern matching algorithm

e Ideally we would like an algorithm that works in O(strlen(str)+ strlen(pat)) time.
This is optimal for this problem as in the worst cast it is necessary to look at all
characters in the pattern and string at least once.

e We want to search the string for the pattern without moving backwards in the string.
That is ifa mismatch occurs we want to use the knowledge of the characters in the
pattern and the position in the pattern where the mismatch occurred to determine
where the search should continue. Knuth, Morris, and pratt have developed an
algorithm that works in this way and has linear complexity.

The following declarations are
assumed .#define
max_string_size 100

#define max_pat_size 100

int pmatch(char *string ,char *pat)
{

int i=0 j=0;

int lens=

strlen(string); int

lenp=

strlen(spat);

while (i<lens

&& j<lenp)

{

if (string[i] == pat|[j])

{

i++; j++; }

else if G==0) i++;

else j= failure[j-1] +1;

i

return ((j=lenp) ? (i-lenp) : -1);
t

Example: For the pattern pat=abcabcacab we have the failure values calculated as below

jo |1)2)3)4)5)6)/7)8) 9} 10

pat |a/|bj|c}a}]|bj]cj]ajecj]ay} b

failure |O}O0/O0]1)2)/3];/1})3)] 14 2

Analysis of pmatch: The time complexity of function pmatch is O (m) = O(strlen(string))
Analysis of fail: The computing time of fails is O(n)=O(strlem(pa)).

Therefore when the failure function is not known in advance the total
computing time isO(strlen(string)) + O(strlem(pa))

SUNIL G L, Dept. of CSE(DS), RNSIT, Bengaluru Page 30