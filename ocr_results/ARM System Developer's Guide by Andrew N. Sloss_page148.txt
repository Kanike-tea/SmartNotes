#define STAGEB (1lul <<1)
#define STAGEC (lul <<2)

5.8 Bit-fields 135

void dostages_v2(Stages_v2 *stages_v2)

{

Stages_v2 stages = *stages_v2;

if (stages & STAGEA)

{
dostageA();
}
if (stages & STAGEB)
{
dostageB();
}
if (stages & STAGEC)
{
dostageC();
}
}

Now that a single unsigned long type contains all the bit-fields, we can keep a copy of
their values in a single local variable stages, which removes the memory aliasing problem
discussed in Section 5.6. In other words, the compiler must assume that the dostageX
(where X is A, B, or C) functions could change the value of *stages_v2.

The compiler generates the following code giving a saving of 33% over the previous

version using ANSI bit-fields:

dostages_v2

STMFD = rl3!,{r4,r14} 5
LOR r4, [r0, #0] 3
TsT r4, #1 3
BLNE dostageA 3
TST 14, #2 3
BLNE dostageB 3
TsT 14, #4 3
LOMNEFD r13!,{r4,r14} 5
BNE dostageC 3
LOMFD = r13!,{r4,pc} 5

stack r4, Ir

stages = *stages_v2

if (stage & STAGEA)
{dostageA();}

if (stage & STAGEB)
{dostageB();}

if (1(stage & STAGEC))

return;

dostageC();

return

You can also use the masks to set and clear the bit-fields, just as easily as for testing
them. The following code shows how to set, clear, or toggle bits using the STAGE masks:

stages |= STAGEA;

/* enable stage A */