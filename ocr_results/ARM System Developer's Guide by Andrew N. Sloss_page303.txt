290 Chapter 8 Digital Signal Processing

Table 8.4

EXAMPLE

8.12

ARMV5TE 16-bit block filter timings.

Processor Inner loop cycles Filter rating cycles/tap
ARM9E 46 46/36 = 1.28
ARMI10E 78 78/36 = 2.17
XScale 46 46/36 = 1.28

SMLATT a4, x 32, c_10, a4

SMLABT a_5, x 54, c 10, a5

BGT next_tap_arm9e

LOMFD  sp!, {a, N, M}

STMIA al, {a.0, al, a2, a3, a4, a5}

suB_ sc, c, M, LSL#1 3 restore coefficient pointer
suB_ x, x, M, LSL#1 3 advance data pointer

suBs oN, N, #6

BGT —_next_sample_arm9e

LDMFD sp!, {r4-rll, pc}

Each iteration of the inner loop updates the next six filter outputs, accumulating six
products to each output. Table 8.4 shows the cycle timings for ARMv5TE architecture
processors.

Sometimes 16-bit data items do not give a large enough dynamic range. The ARMv5TE
architecture adds an instruction SMLAWx that allows for efficient filtering of 32-bit data by
16-bit coefficients. The instruction multiplies a 32-bit data item by a 16-bit coefficient,
extracts the top 32 bits of the 48-bit result, and adds it to a 32-bit accumulator.

This example implements a 5 x 4 block FIR filter with 32-bit data and 16-bit coefficients.
The input and output arrays have the same format as Example 8.9, except that the coefficient
array is 16-bit. The number of outputs must be a multiple of five and the number of
coefficients a multiple of four. The input coefficient array must be 32-bit aligned and the
memory system little-endian. As described in Example 8.11, you can write endian-neutral
code by using macros.

If the input samples and coefficients use Qn and Qm representations, respectively, then
the output is Q(n + m — 16). The SMLAWx shifts down by 16 to prevent overflow.

RN 0 array for output samples aL]
RN 1; array of input samples x(]
RN 2; array of coefficients c[] (32-bit aligned)

RN 3; number of outputs (a multiple of 5)
RN 4 — ; number of coefficients (a multiple of 4)
10 RNO — ; coefficient pair

0 =Z2z0xe