Microcontrollers — BCS402

add_vl
ADD r0,r0,rl,ASR #1 3; rO = (int)a + ((int)b>>1)
Mov r0,r0,LSL #16
Mov r0,r0,ASR #16 3 70 = (short)ro
Mov pe, rl4 3; return r0

The gcc compiler we used is more cautious and makes no assumptions about the range of
argument value. This version of the compiler reduces the input arguments to the range of a

short in both the caller and the callee. It also casts the return value to a short type.
Here is the compiled code for add_v1:
add_vl_gec

Mov ro, ro, LSL #16
MoV rl, rl, LSL #16

MOV rl, rl, ASR #17 3 Pl = (int)b>>1
ADD rl, rl, rO, ASR #16 3 rl += (int)a
MoV rl, rl, LSL #16

MOV ro, rl, ASR #16 ; rO = (short)rl
MOV pe, Ir ; return ro

2.3 Signed versus Unsigned Types
This section compares the efficiencies of signed int and unsigned int.

If your code uses addition, subtraction, and multiplication, then there is no performance
difference between signed and unsigned operations. However, there is a difference when it

comes to division. Consider the following short example that averages two integers:

int average vl(int a, int b)
{

return (atb) /2;
}

This compiles to

average _vl
‘ADD 10,10, rl sr0=a+b
ADD r0,r0,r0,LSR #31 3 1f (r0<0) rot
Mov rO,rO,ASR #1 370 = rO>>1
Nov pe,rl4 3 return ro

Dept. of ECE, GSSSIETW Page 38